import org.fest.assertions.Assertions;
import org.junit.jupiter.api.Test;

import static org.fest.assertions.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;

/**
 * Created by USER on 2017-01-28.
 */
public class PercolationOpenTest {
    @org.junit.jupiter.api.BeforeEach
    void setUp() {

    }
/*

    @Test
    void shouldThrowExceptionWhenIndexesAreSmallerThanTheRange() {
        //given
        int n = 4;
        final Percolation percolation = new Percolation(n);

        //when

        Throwable exception = assertThrows(IndexOutOfBoundsException.class, () -> {
            percolation.open(0, 3);
        });
    }

    @Test
    void shouldThrowExceptionWhenIndexesAreBiggerThanTheRange() {
        //given
        int n = 4;
        final Percolation percolation = new Percolation(n);

        //when

        Throwable exception = assertThrows(IndexOutOfBoundsException.class, () -> {
            percolation.open(0, n + 1);
        });
    }

    @Test
    void shouldNotThrowExceptionWhenIndexesAreInRange() {
        //given
        int n = 4;
        final Percolation percolation = new Percolation(n);

        //when
        percolation.open(n, n);

        //then
        // no exception
    }


    @Test
    void shouldOpenTopLeftCornerSiteWithNoOpenNeighbours() {
        //given
        int n = 2;
        final Percolation percolation = new Percolation(n);
        int i = 1;
        int j = 1;

        //when
        percolation.open(i, j);

        //then
        Assertions.assertThat(percolation.isOpen(i, j)).isTrue();

    }

    @Test
    void shouldOpenTopRightCornerSiteWithNoOpenNeighbours() {
        //given
        int n = 2;
        final Percolation percolation = new Percolation(n);
        int i = 1;
        int j = 2;

        //when
        percolation.open(i, j);

        //then
        Assertions.assertThat(percolation.isOpen(i, j)).isTrue();
    }

    @Test
    void shouldOpenBottomLeftCornerSiteWithNoOpenNeighbours() {
        //given
        int n = 2;
        final Percolation percolation = new Percolation(n);
        int i = 2;
        int j = 1;

        //when
        percolation.open(i, j);

        //then
        Assertions.assertThat(percolation.isOpen(i, j)).isTrue();
    }

    @Test
    void shouldOpenBottomRightCornerSiteWithNoOpenNeighbours() {
        //given
        int n = 2;
        final Percolation percolation = new Percolation(n);
        int i = 2;
        int j = 2;

        //when
        percolation.open(i, j);

        //then
        Assertions.assertThat(percolation.isOpen(i, j)).isTrue();
    }

    @Test
    void shouldOpenCornerSiteWithBothOpenNeighbours() {
        //given
        int n = 2;
        final Percolation percolation = new Percolation(n);

        percolation.grid[0][0] = true;
        percolation.grid[1][1] = true;

        //when
        percolation.open(1, 2);

        //then
        Assertions.assertThat(percolation.isOpen(1, 2)).isTrue();

        //assert that [1,1] is connected with [1,1]
        Assertions.assertThat(percolation.union.connected(mapTo1D(1, 1, n), mapTo1D(1, 2, n))).isTrue();
        Assertions.assertThat(percolation.union.connected(mapTo1D(1, 1, n), mapTo1D(2, 2, n))).isTrue();
        Assertions.assertThat(percolation.union.connected(mapTo1D(2, 2, n), mapTo1D(1, 2, n))).isTrue();
    }

    @Test
    void shouldDoNothingIfTheSiteIsOpenAlready() {
        //given
        int n = 2;
        final Percolation percolation = new Percolation(n);
        int row = 1;
        int col = 2;
        percolation.grid[0][0] = true;
        percolation.grid[1][1] = true;
        percolation.grid[row - 1][col - 1] = true;

        //when
        percolation.open(row, col);

        //then
        Assertions.assertThat(percolation.isOpen(row, col)).isTrue();


        //other should be disconected
        Assertions.assertThat(percolation.union.connected(mapTo1D(2, 2, n), mapTo1D(1, 2, n))).isFalse();
        Assertions.assertThat(percolation.union.connected(mapTo1D(1, 1, n), mapTo1D(2, 2, n))).isFalse();
    }


    @Test
    void shouldOpenMiddleSiteWithAllOpenNeighbours() {
        //given
        int n = 3;
        final Percolation percolation = new Percolation(n);

        percolation.grid[0][1] = true;
        percolation.grid[1][0] = true;
        percolation.grid[1][2] = true;
        percolation.grid[2][1] = true;

        int row = 2, col = 2;
        //when
        percolation.open(row, col);

        //then
        Assertions.assertThat(percolation.isOpen(row, col)).isTrue();

        //assert that [1,1] is connected with [1,1]
        Assertions.assertThat(percolation.union.connected(mapTo1D(1, 2, n), mapTo1D(row, col, n))).isTrue();
        Assertions.assertThat(percolation.union.connected(mapTo1D(2, 1, n), mapTo1D(row, col, n))).isTrue();
        Assertions.assertThat(percolation.union.connected(mapTo1D(2, 3, n), mapTo1D(row, col, n))).isTrue();
        Assertions.assertThat(percolation.union.connected(mapTo1D(3, 2, n),mapTo1D(row, col, n))).isTrue();
    }


    @Test
    public void shouldOpenSiteIn1SizeGrid()
    {
        //given
        int n = 1;
        Percolation prelocation = new Percolation(n);

        //when
        prelocation.open(1,1);

        //then
        assertThat(prelocation.grid[0][0]).isTrue();
        assertThat(prelocation.isOpen(1,1)).isTrue();
    }


    public static int mapTo1D(int i, int j, int n) {
        i--;
        j--;
        return i * n + j;
    }

*/

}